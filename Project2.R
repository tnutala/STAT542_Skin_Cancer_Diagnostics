#######################################
#######################################
### READ ME ###

# This R file is intended as a supplement to Part 2, 
# corresponding to feature extraction and feature-based classification

#######################################
#######################################

#
### Asymmetry Feature
#

library("imager")

circlemask = draw_circle(imfill(256, 256, val = c(0, 0, 0)), 128, 128, 128)
angleinc = 5
angles = 0:(90 / angleinc) * angleinc

#load the image, pad it out to make it square, then drop a circle mask on top of it
preprocess = function(imgpath) {
  img = load.image(imgpath)
  img.top = imsub(img, y <= 4)
  
  r = mean(as.numeric(channel(img.top, 1)))
  g = mean(as.numeric(channel(img.top, 2)))
  b = mean(as.numeric(channel(img.top, 3)))
  
  img.pad = pad(img, dim(img)[1] - dim(img)[2], "y", 0, c(r, g, b))
  img.res = resize(img.pad, 256, 256)
  img.masked = mult(imlist(img.res, circlemask))
}

#mirror the left, overlay it on top of the right, and check the mean square difference
checkasymmetry = function(img) {
  img.left = imsub(img, x <= 128)
  img.left.mirror = mirror(img.left, "x")
  img.right = imsub(img, x > 128)
  
  img.left.r = channel(img.left.mirror, 1)
  img.right.r = channel(img.right, 1)
  img.left.g = channel(img.left.mirror, 2)
  img.right.g = channel(img.right, 2)
  img.left.b = channel(img.left.mirror, 3)
  img.right.b = channel(img.right, 3)
  
  
  diffs = (as.numeric(img.left.r) - as.numeric(img.right.r))^2 + 
    (as.numeric(img.left.g) - as.numeric(img.right.g))^2 +
    (as.numeric(img.left.b) - as.numeric(img.right.b))^2
  
  sqrt(mean(diffs))
}

#rotate the image, crop the excess generated by the rotation algorithm, then check asymmetry
checkasymmetry.rot = function(rot, img) {
  img.rot = imrotate(img, rot)
  img.crop = crop.borders(img.rot, (dim(img.rot)[1] - 256)/2, (dim(img.rot)[2] - 256)/2)
  checkasymmetry(img.crop)
}

#run through all of our angles, and find the minimum asymmetry value
checkangles = function(img) {
  min(sapply(angles, function(a) {
    checkasymmetry.rot(a, img)
  }))
  
}

#read an image and run it through the asymmetry measuring
measureasymm = function(imgpath) {
  print(paste("Measuring", imgpath))
  img = preprocess(imgpath)
  checkangles(img)
}

#measure the asymmetry for every file in a directory
measureasymm.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureasymm(file.path(d, x))
  })
}


#
### Color features
#

#make a matrix of the pixel values of the grayscale image
intensity = function(img) {
  as.numeric(grayscale(img))
}

#load an image and take the mean of the intensity
measureintensity = function(imgpath) {
  gc()
  print(imgpath)
  img = load.image(imgpath)
  mean(intensity(img))
}

#read the intensity values for all files in a dir
measureintensity.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureintensity(file.path(d, x))
  })
}

#measure the variance of the intensity values
measureintensityvar = function(imgpath) {
  gc()
  print(imgpath)
  img = load.image(imgpath)
  var(intensity(img))
}

#measure the intensity values for each file in a dir
measureintensityvar.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureintensityvar(file.path(d, x))
  })
}

#take each pixel's blue channel, subtract the max of its red and green, and cap the bottom end at 0
blue = function(img) {
  b = channel(img, 3)
  rg = pmax(as.numeric(channel(img, 1)), as.numeric(channel(img, 2)))
  pmax(0, b - rg)
}

#take the mean of the blue measure above for the given image
measureblue = function(imgpath) {
  gc()
  print(imgpath)
  img = load.image(imgpath)
  mean(blue(img))
}

#take the variance of the blue measure for the given image
measurebluevar = function(imgpath) {
  gc()
  print(imgpath)
  img = load.image(imgpath)
  var(blue(img))
}

#measure the mean blue for all images in a directory
measureblue.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureblue(file.path(d, x))
  })
}

#measure the blue variance for all images in a directory
measurebluevar.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureblue(file.path(d, x))
  })
}

#take each pixel's red channel, subtract the max of its blue and green, and cap the bottom end at 0
red = function(img) {
  r = channel(img, 1)
  gb = pmax(as.numeric(channel(img, 2)), as.numeric(channel(img, 3)))
  pmax(0, r - gb)
}

#take the mean of the red measure above for the given image
measurered = function(imgpath) {
  gc()
  print(imgpath)
  img = load.image(imgpath)
  mean(red(img))
}

#take the variance of the red measure for the given image
measureredvar = function(imgpath) {
  gc()
  print(imgpath)
  img = load.image(imgpath)
  var(red(img))
}

#measure the mean red for all images in a directory
measurered.dir = function(d) {
  sapply(list.files(d), function(x) {
    measurered(file.path(d, x))
  })
}

#measure the red variance for all images in a directory
measureredvar.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureredvar(file.path(d, x))
  })
}


#
### Border feature
#

library(opencv)

#take the mean of the edges detected by opencv
measureedge = function(imgpath) {
  img = ocv_read(imgpath)
  mean(as.numeric(ocv_bitmap(ocv_edges(ocv_resize(img, 256, 256)))))
}

#measure the edges of each image in a directory
measureedge.dir = function(d) {
  sapply(list.files(d), function(x) {
    measureedge(file.path(d, x))
  })
}

#
### Data processing
#

ben.asym = measureasymm.dir("benign")
mal.asym = measureasymm.dir("malignant")

ben.int = measureintensity.dir("benign")
mal.int = measureintensity.dir("malignant")

ben.intvar = measureintensityvar.dir("benign")
mal.intvar = measureintensityvar.dir("malignant")

ben.blue = measureblue.dir("benign")
mal.blue = measureblue.dir("malignant")

ben.red = measurered.dir("benign")
mal.red = measurered.dir("malignant")

ben.bluevar = measurebluevar.dir("benign")
mal.bluevar = measurebluevar.dir("malignant")

ben.redvar = measureredvar.dir("benign")
mal.redvar = measureredvar.dir("malignant")

ben.edge = measureedge.dir("benign")
mal.edge = measureedge.dir("malignant")

y = numeric(length(list.files("benign")))
y = c(y, rep(1, length(list.files("malignant"))))

x = data.frame(intensity = c(ben.int, mal.int), 
               #intensitysd = sqrt(c(ben.intvar, mal.intvar)),
               asymmetric = c(ben.asym, mal.asym), 
               blue = c(ben.blue, mal.blue), 
               red = c(ben.red, mal.red), 
               #bluesd = sqrt(c(ben.bluevar, mal.bluevar)), 
               #redsd = sqrt(c(ben.redvar, mal.redvar)),
               edge = c(ben.edge, mal.edge),
               malignant = y)

#
### Classification
#

#x = read.csv("data_features.csv")

library(caret)
library(randomForest)
set.seed(1)
inTrain = createDataPartition(y = as.factor(x$malignant), p = .75, list = F)
x[,1:5] = scale(x[,1:5])
training = x[inTrain,]
testing = x[-inTrain,]

#random forest
caret.rf.fit = train(as.factor(malignant) ~ ., data = training, method = "rf")
rf.pred = predict(caret.rf.fit, testing)

print("Overall accuracy in testing set for Random Forest")
mean(rf.pred == testing$malignant)
print("Type I Error")
sum(rf.pred[testing$malignant == 0] != 0)
print("Benign as Benign")
sum(rf.pred[testing$malignant == 0] == 0)

print("Type II Error")
sum(rf.pred[testing$malignant == 1] != 1)
print("Malignant as Malignant")
sum(rf.pred[testing$malignant == 1] == 1)

print("Important variables")
#rf.vars = importance(caret.rf.fit$finalModel)
#rf.vars[order(rf.vars, decreasing = T),]
varImp(caret.rf.fit)

print("Tuning parameters")
caret.rf.fit
plot(caret.rf.fit$finalModel, main = "Random Forest Error")

#penalized logistic regression
caret.log.fit = train(factor(malignant) ~ ., data = training, method = "glmnet")
log.pred = predict(caret.log.fit, testing)

print("Overall accuracy in testing set for Penalized Logistic Regression")
mean(log.pred == testing$malignant)
print("Type I Error")
sum(log.pred[testing$malignant == 0] != 0)
print("Benign as Benign")
sum(log.pred[testing$malignant == 0] == 0)

print("Type II Error")
sum(log.pred[testing$malignant == 1] != 1)
print("Malignant as Malignant")
sum(log.pred[testing$malignant == 1] == 1)

print("Tuning parameters")
caret.log.fit

print("Important variables")
varImp(caret.log.fit, lambda = caret.log.fit$lambda.min)
